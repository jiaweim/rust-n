# 基本类型

- [基本类型](#基本类型)
  - [1. 简介](#1-简介)
  - [2. 类型推导与标注](#2-类型推导与标注)
  - [3. 数值类型](#3-数值类型)
    - [3.1. 整数](#31-整数)
    - [3.2. 整型溢出](#32-整型溢出)
    - [3.3. 浮点数](#33-浮点数)
      - [浮点数陷阱](#浮点数陷阱)
      - [NaN](#nan)
  - [4. 数学运算](#4-数学运算)
  - [5. 位运算](#5-位运算)
  - [6. 序列](#6-序列)
  - [7. 有理数和复数](#7-有理数和复数)

2023-10-31, 19:44
update: 细化内容
2023-10-17, 11:28
@author Jiawei Mao
****

## 1. 简介

Rust 数据类型可以分为两类：基本类型和复合类型。

基本类型包括：

- 数值类型
- 字符串：字符串字面量和字符串切片 `&str`
- 布尔类型： `true` 和 `false`
- 字符类型: 表示单个 Unicode 字符，存储为 4 个字节
- 单元类型: 即 `()` ，其唯一的值也是 `()`

Rust 类型示例：

|类型|说明|值|
|---|---|---|
|i8, i16, i32, i64, i128, u8, u16, u32, u64, u128|有符号整数和无符号整数|42, -5i8, 0x400u16, 0o100i16, 20_922_789_888_000u64, b'*' (u8 byte literal)|
|isize, usize|与机器指针一样宽的有符号整数和无符号整数|`137`, `-0b0101_0010isize`, `0xffff_fc00usize`|
|f32, f64|IEEE 单精度和双精度浮点数|1.61803, `3.14f32`, `6.0221e23f64`|
|bool|布尔值|true, false|
|`char`|Unicode 字符， 32 位宽(4 字节) |'*', '\n', '字', '\x7f', '\u{CA0}'|
|(char, u8, i32)|元组，允许混合类型|('%', 0x7f, -1)|
|()|“Unit” (空元组)|()|
|struct S { x: f32, y: f32 }|具名结构体| S { x: 120.0, y: 209.0 }|
|struct T (i32, char);|元组型结构体|T(120, 'X')|
|struct E;|单元型结构体，无字段|E|
|enum Attend { OnTime, Late(u32) }|枚举| `Attend::Late(5)`, `Attend::OnTime`|
|`Box<Attend>`| Box: 指向堆中值的拥有型指针|Box::new(Late(15))|
|`&i32`, `&mut i32`|共享引用和可变引用：非拥有型指针，生命周期不能超出引用目标|&s.y, &mut v|
|String|UTF-8 字符串，动态分配大小|"ラーメン: ramen".to_string()|
|`&str`|对 str 的引用：指向 UTF-8 文本的非拥有型指针|"そば: soba", `&s[0..12]`|
|[f64; 4], [u8; 256]|数组，固定长度，元素类型相同|[1.0, 0.0, 0.0, 1.0], [b' '; 256]|
|`Vec<f64>`|向量，可变长度，元素类型相同|vec![0.367, 2.718, 7.389]|
|`&[u8]`,`&mut [u8]`|对切片（数组或向量的一部分）的引用，包含指针和长度|`&v[10..20]`, `&mut a[..]`|
|`Option<&str>`|可选值：None 或者 Some(v)|Some("Dr."), None|
|`Result<u64, Error>`|可能失败的操作结果：Ok(v)或者 Err(e)|Ok(4096),Err(Error::last_os_error())|
|`&dyn Any`, `&mut dyn Read`|特型对象，是对任何实现一组给定方法的值的引用|`value as &dyn Any`, &mut file as &mut dyn Read|
|`fn(&str) -> bool`|函数指针|str::is_empty|
|闭包没有编写形式|闭包|`\|a, b\| { a*a + b*b }`|

## 2. 类型推导与标注

Rust 是一门静态类型语言，编译器必须在编译期知道所有变量的类型，但这不意味着你需要为每个变量指定类型：

- Rust 编译器可以根据变量的值和上下文中的使用方式来自动推导出变量的类型
- 在编译器无法推导出变量类型时，需要手动标注类型

**示例：** 无法推断出类型

```rust
let guess = "42".parse().expect("Not a number!");
```

编译器无法确定 "42" 是整数、浮点数还是字符串，因此会报错：

```sh
error[E0282]: type annotations needed        
  --> src\main.rs:10:9
   |
10 |     let guess = "42".parse().expect("Not a number!");
   |         ^^^^^
   |
help: consider giving `guess` an explicit type
   |
10 |     let guess: /* Type */ = "42".parse().expect("Not a number!");
   |              ++++++++++++
```

此时需要显标注类型：

```rust
let guess: i32 = "42".parse().expect("Not a number!");
```

或者：

```rust
let guess = "42".parse::<i32>().expect("Not a number!");
```

## 3. 数值类型

Rust 的数值类型与其它语言较为相似，但也有差异：

- Rust 数值类型很多
- 类型转换必须显式，例如，Rust 不会主动帮你把 16bit 整数转换为 32bit 整数

### 3.1. 整数

整数分为两种类型：

- 无符号（unsigned） `u`：只能表示非负数，存储数字范围为 $[0, 2^n-1]$
- 有符号（signed） `i`：可以表示负数，存储数字范围 $[-2^{n-1}, 2^{n-1}-1]$

例如，`i8` 的数字范围为 $[-2^7,2^7-1]=[-128,127]$；`u8` 的数字范围为 $[0, 2^8-1]=[0,255]$。

|长度（bit）|有符号整数|无符号整数|
|---|---|---|
|8|i8|u8|
|16|i16|u16|
|32|i32|u32|
|64|i64|u64|
|128|i128|u128|
|arch|isize|usize|

`isize` 和 `usize` 类型取决于运行程序的 CPU 类型：64-bit 机器上为 64-bit；32-bit 机器上为 32-bit。

**无符号整型**

|类型|范围|
|---|---|
|u8|0 到 2^8-1 (255)|
|u16|0 到 2^16-1 (65535)|
|u32|0 到 2^32-1 (4,294,967,295)|
|u64|0 到 2^64-1 (18,446,744,073,709,551,615)|
|u128|0 到 2^128-1 (约 3.4✕10^38)|
|usize|0 到 2^32-1 或 2^64-1|

**示例：** 整形字面量

|数字字面量|示例|说明|
|---|---|---|
|十进制|`98_222`||
|十六进制|`0xff`|前缀：`0x`|
|八进制|`0o77`|前缀：`0o`|
|二进制|`0b1111_0000`|前缀：`0b`|
|字节 ( u8 only)|`b'A'`||

注意：

- 整数类型默认为 `i32`，为推荐使用类型
- `isize` 或 `usize` 主要用作集合索引，数组或向量大小，数据结构中元素数量等
- 可以在数字任意位置插入 `_`，使长数字更易读
  - u32 的最大值：4_294_967_295
  - 十六进制按 4 位分组：0xffff_ffff
  - 分开类型后缀：127_u8
- b'X' 表示以字符 `X` 的 ASCII 码作为 u8 值，例如，`A` 的 ASCII 码是 65，因此字面量 b'A' 和 65u8 完全等效。
- 仅 ASCII 字符能作为**字节字面量**

**必须转义的字符**

|字符|字节字面量|等效数值|
|---|---|---|
|单引号 '| `b'\''`|39u8|
|反斜杠 `\`|`b'\\'`|92u8|
|换行|`b'\n'`|10u8|
|回车|`b'\r'`|13u8|
|制表符|`b'\t'`|9u8|

### 3.2. 整型溢出

类型为 `u8` 的变量可以保存 [0, 255] 的值，如果将其赋值为 256，就发生整数溢出。整数溢出会出现两种情况：

- 在 debug 模式，Rust 会检查整数溢出，出现溢出时抛出异常
- 在 `--release` 模式，Rust 不检查整数溢出。发生溢出时，大于该类型最大值时会按照补码循环溢出处理，比如对 `u8`，256 变为 0，257 变为 1，依此类推。程序不会 panic，但结果不是所期望的。
    
标准库为基本类型提供了显式处理溢出的方法：
    
- 所有模式下都 wrap 的 `wrapping_*` 函数，如 `wrapping_add`
- 出现溢出时返回 `None` 的 `checked_*` 方法
- 同时返回值和表示是否溢出的 boolean 值的 `overflowing_*` 方法
- 在最小值或最大值处饱和的 `saturating_*` 方法

**示例：** `wrapping_add`

```rust
fn main() {
    let a : u8 = 255;
    let b = a.wrapping_add(20);
    println!("{}", b);  // 19
}
```

### 3.3. 浮点数

Rust 有两种浮点类型：

- `f32`
- `f64`

默认类型为 `f64`，其速度与 `f32` 大致相同，但精度更高。所有浮点类型都有符号。

**示例：** 浮点数

```rust
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```

#### 浮点数陷阱

浮点数的底层格式特殊，如果使用时不够谨慎，会造成危险，有两个原因：

1. **浮点数往往是你想要表达数字的近似**

浮点数类型基于二进制实现，但是我们想要计算的数字往往是基于十进制，例如 `0.1` 在二进制上不存在精确的表达形式，但是在十进制存在。另外，由于底层格式问题，浮点数精度有限。

2. **浮点数在某些特性上是反直觉的**

例如大家都会觉得浮点数可以进行比较，它们确实可以使用 `>`，`>=` 等进行比较，但是在某些场景下，这种直觉上的比较特性反而会害了你。因为 `f32` ，`f64` 上的比较运算实现的是 `std::cmp::PartialEq` trait，而没有实现 `std::cmp::Eq` trait，但是后者在其它数值类型上都有定义。

**示例：**

Rust 的 `HashMap` 是一个 KV 类型的 Hash Map 实现，它对于 `K` 没有特定类型的限制，但要求 K 的类型必须实现了 `std::cmp::Eq` trait，因此无法使用浮点数作为 `HashMap` 的 `Key`，但是Rust 的整数类型、字符串类型、布尔类型都实现了该特征，可以作为 `HashMap` 的 `Key`。

为了避免上面说的两个问题，需要遵守以下准则：

- 避免在浮点数上测试相等性
- 当结果在数学上可能存在未定义时，需要格外的小心

**示例：** 测试浮点数相等性

```rust
fn main() {
  // 断言0.1 + 0.2与0.3相等
  assert!(0.1 + 0.2 == 0.3);
}
```

这段代码会 panic，因为二进制精度问题，导致 `0.1 + 0.2` 并不严格等于 0.3，可能在小数点 N 位后存在误差。

如果确实需要比较，可以考虑如下方式：

```rust
(0.1_f64 + 0.2 - 0.3).abs() < 0.00001
```

#### NaN

数学上未定义的结果，例如给负数取平方根 `-42.1.sqrt()`，在 Rust 中返回 `NaN` (not a number)。

所有跟 `NaN` 交互的操作，都返回 `NaN`，而且 `NaN` 不能用来比较，否则 panic。

**示例：** 比较 `NaN` 导致 panic

```rust
fn main() {
    let x = (-42.0_f32).sqrt();
    assert_eq!(x, x);
}
```

`assert_eq!(x, x)` 比较 `NaN`，所以 panic。

可以用 `is_nan()` 检查是否为 `NaN`：

```rust
fn main() {
    let x = (-42.0_f32).sqrt();
    if x.is_nan() {
        println!("未定义的数学行为")
    }
}
```

## 4. 数学运算

Rust 支持加、减、乘、除和余数等基本数学运算。整数除法会向 0 截断到最接近的整数。例如：

```rust
fn main() {
    // 加法
    let sum = 5 + 10;

    // 减法
    let difference = 95.5 - 4.3;

    // 乘法
    let product = 4 * 30;

    // 除法
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // Results in -1

    // 求余
    let remainder = 43 % 5;
}
```

**示例：** 各种表示展示

```rust
fn main() {
    // 编译器会进行自动推导，给予twenty i32的类型
    let twenty = 20;
    // 类型标注
    let twenty_one: i32 = 21;
    // 通过类型后缀的方式进行类型标注：22是i32类型
    let twenty_two = 22i32;
    // 通过类型后缀的方式进行类型标注：23是i32类型
    let twenty_three = 23_i32;
    // 只有同样类型，才能运算
    let addition = twenty + twenty_one + twenty_two + twenty_three;
    println!("{} + {} + {} + {} = {}", twenty, twenty_one, twenty_two, twenty_three, addition);

    // 对于较长的数字，可以用 _ 进行分割，提升可读性
    let one_million: i64 = 1_000_000;
    println!("{}", one_million.pow(2));
    // 定义一个f32数组，其中42.0会自动被推导为f32类型
    let forty_twos = [
        42.0,
        42f32,
        42.0_f32,
    ];
    // 打印数组中第一个值，并控制小数位为2位
    println!("{:.2}", forty_twos[0]);
}
```

```sh
20 + 21 + 22 + 23 = 86
1000000000000
42.00
```

## 5. 位运算

Rust 的位运算和其他语言基本一样

|运算符|操作|说明|
|---|---|---|
|`&` |位与 |相同位置均为1时则为1，否则为0|
| `\|`|位或 |相同位置只要有1时则为1，否则为0|
|`^` |异或 |相同位置不相同则为1，相同则为0|
|`!` |位非 |把位中的0和1相互取反，即0置为1，1置为0|
|`<<`| 左移| 所有位向左移动指定位数，右位补0|
|`>>`| 右移| 所有位向右移动指定位数，带符号移动（正数补0，负数补1）|

**示例：** 位运算

```rust
fn main() {
    // 二进制为00000010
    let a: i32 = 2;
    // 二进制为00000011
    let b: i32 = 3;

    println!("(a & b) value is {}", a & b);
    println!("(a | b) value is {}", a | b);
    println!("(a ^ b) value is {}", a ^ b);
    println!("(!b) value is {} ", !b);
    println!("(a << b) value is {}", a << b);
    println!("(a >> b) value is {}", a >> b);
    let mut a = a;

    // 注意这些计算符除了!之外都可以加上=进行赋值 (因为!=要用来判断不等于)
    a <<= b;
    println!("(a << b) value is {}", a);
}
```

```
(a & b) value is 2
(a | b) value is 3
(a ^ b) value is 1
(!b) value is -4 
(a << b) value is 16
(a >> b) value is 0
(a << b) value is 16
```

## 6. 序列

Rust 提供了生成连续数值的简洁方式，例如：

- `1..5` 生成 1 到 4 的连续数字
- `1..=5` 生成 1 到 5 的连续数字

整数序列常用于循环：

```rust
fn main() {
    for i in 1..=5 {
        println!("{}", i);
    }
}
```

```
1
2
3
4
5
```

序列只允许用于数字和字符类型。

**示例：** 字符类型序列

```rust
for i in 'a'..='z' {
    println!("{}",i);
}
```

## 7. 有理数和复数

有理数和复数不在标准库中，`num` 库提供了这些功能。

使用 `num` 库：

1. 在 Cargo.toml 的 `[dependencies]` 下添加一行 `num = "0.4.1"`
2. 编写代码

```rust
use num::complex::Complex;

fn main() {
    let a = Complex { re: 2.1, im: -1.2 };
    let b = Complex::new(11.1, 22.2);

    let result = a + b;

    println!("{} + {}i", result.re, result.im);
}
```

```
13.2 + 21i
```

