# 智能指针

- [智能指针](#智能指针)
  - [简介](#简介)
  - [Box](#box)
    - [Rust 中的堆栈](#rust-中的堆栈)
    - [Box 的使用场景](#box-的使用场景)
      - [将数据存储到堆上](#将数据存储到堆上)
      - [避免拷贝栈数据](#避免拷贝栈数据)
      - [将动态大小类型变为 Sized 固定大小类型](#将动态大小类型变为-sized-固定大小类型)
      - [特征对象](#特征对象)
    - [Box 内存布局](#box-内存布局)
    - [Box::leak](#boxleak)

***

## 简介

指针：一个包含内置地址的变量，该内存地址引用或指向另外的数据。

引用是最常见的指针类型，通过 `&` 表示。

智能指针和引用的区别：

- 智能指针比引用复杂，包含比引用更多的信息，如元数据，当前长度，最大可用长度等。
- 引用仅仅借用数据，而智能指针往往可以拥有它指向的数据，然后再为其它人提供服务。

智能指针一般基于 struct 实现，它与自定义结构体最大的区别在于它实现了 `Deref` 和 `Drop` 特征：

- `Deref` 让智能指针像引用一样工作，这样就可以写出同时支持智能指针和引用的代码，如 `*T`
- `Drop` 用于指定智能指针超出作用域后自动执行的代码，例如一些数据清理等收尾工作

## Box

`Box<T>` 是 Rust 中最常用的智能指针。`Box<T>` 将数据分配到堆上，在栈上保留一个指向数据的智能指针。

### Rust 中的堆栈

栈内存从高位地址向下增长，且栈内存是连续分配的。操作系统对栈内存的大小通常有限制，因此 C 语言无法创建任意长度的数组。在 Rust 中，`main` 线程的栈大小是 8MB，普通线程是 2MB，在函数调用时会在其中创建 一个临时栈空间，调用结束后 Rust 会让这个栈空间里的对象自动进入 `Drop` 流程，最后栈顶指针自动移动到上一个调用栈顶，因而栈内存申请和释放非常高效。

与栈相反，堆上内存从低位地址向上增长，**堆内存通常只受物理内存限制**，而且通常不连续，因此栈的性能通常比堆高。

与其它语言相比，Rust 堆上对象还有一个所有者，因此受所有者规则限制：当赋值时，所有权转移（不拷贝数据，只浅拷贝栈上的引用或智能指针）。例如：

```rust
fn main() {
    let b = foo("world");
    println!("{}", b);
}

fn foo(x: &str) -> String {
    let a = "Hello, ".to_string() + x;
    a
}
```

在 `foo` 函数中，`a` 是 `String` 类型，是一个智能指针 struct，该智能指针存储在函数栈中，指向堆上的字符串数据。当 `a` 从 `foo` 函数转移到 `main` 中的变量 `b` 时，栈上的智能指针被复制一份到 b，而底层数据不变。

**堆栈性能**

- 小型数据，在栈上的分配性能和读取性能都比堆高
- 中型数据，栈上分配性能高，但是读取性能和堆上无差别，因为无法利用寄存器或高速 CPU 缓存，最终还是要经过一次寻址
- 大型数据，只建议在堆上分配和使用

总之，栈上的分配速度肯定比堆上快，但是读取速度取决于数据能够放入寄存器或高速 CPU 缓存。

### Box 的使用场景

`Box` 是简单的封装，除了将值存储在堆上，没有其它性能上的损耗。Box 相比其它智能指针，功能较为单一，应用场景有：

- 特意将数据分配到堆上
- 数据较大时，又不想在转移所有权时进行数据拷贝
- 类型的大小在编译时无法确定，但是 又需要固定大小的类型时
- 特征对象，用于说明对象实现了一个特征，而不是某个特定的类型

#### 将数据存储到堆上

数值变量如 `let a = 3`，变量 `a` 必然是存储在栈上的，如果我们想要 `a` 的值存储在堆上，就需要使用 `Box<T>` ：

```rust
fn main() {
    let a = Box::new(3);
    println!("a = {}", a); // a = 3
    // 下面一行代码将报错
    // let b = a + 1; // cannot add `{integer}` to `Box<{integer}>`
}
```

这样就创建了一个指向存储在堆上的 `3` 的智能指针，`a` 持有该指针。

智能指针一般实现了 `Deref` 和 `Drop` 特征，因此：

- `println!` 可以正常打印 a 的值，因为它隐式调用 `Deref` 对智能指针 `a` 进行解引用
- 最后一行代码 `let b = a + 1` 报错，因为在表达式中无法自动执行 `Deref` 解引用操作，需要使用 `*` 操作符 `let b = *a + 1`，来显式的进行解引用
- `a` 持有的智能指针将在作用域结束（ main 函数结束）时，被释放掉，这是因为 `Box<T>` 实现了 `Drop` 特征

#### 避免拷贝栈数据

当栈上数据移交所有权时，会把数据拷贝一份，使新旧变量各自拥有一套数据，因此所有权并未转移。

而堆上不同，底层数据不会拷贝，转移所有权仅复制栈中的指针，再将新的指针赋予新的变量，并让拥有旧指针的变量失效，最终完成所有权转移：

```rust
fn main() {
    // 在栈上创建一个长度为1000的数组
    let arr = [0;1000];
    // 将arr所有权转移arr1，由于 `arr` 分配在栈上，因此这里实际上是直接重新深拷贝了一份数据
    let arr1 = arr;

    // arr 和 arr1 都拥有各自的栈上数组，因此不会报错
    println!("{:?}", arr.len());
    println!("{:?}", arr1.len());

    // 在堆上创建一个长度为1000的数组，然后使用一个智能指针指向它
    let arr = Box::new([0;1000]);
    // 将堆上数组的所有权转移给 arr1，由于数据在堆上，
    // 因此仅仅拷贝了智能指针的结构体，底层数据并没有被拷贝
    // 所有权顺利转移给 arr1，arr 不再拥有所有权
    let arr1 = arr;
    println!("{:?}", arr1.len());
    // 由于 arr 不再拥有底层数组的所有权，因此下面代码将报错
    // println!("{:?}", arr.len());
}
```

从以上代码可以看出大块的数据为何应该放入堆中，此时 `Box` 就成为了我们最好的帮手。

#### 将动态大小类型变为 Sized 固定大小类型

Rust 在编译时需要知道类型占用多少空间。在编译时不知道具体大小的类型称为**动态大小类型** DST。

以递归类型为例：在类型定义中使用了自身，这种值的嵌套理论上可以无限下去，所以 Rust 不知道递归类型需要多少空间。以 linked-list 为例：

```rust
enum List {
    Cons(i32, List),
    Nil,
}
```

每个节点包含一个 `i32` 值和一个新的 `List`，Rust 认为该类型是 DST 类型，报错：

```sh
error[E0072]: recursive type `List` has infinite size //递归类型 `List` 拥有无限长的
大小
 --> src/main.rs:3:1
  |
3 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
4 |     Cons(i32, List),
  |               ---- recursive without indirection
```

可以使用 Box 解决该问题：

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}
```

即将 `List` 存储到堆上，然后使用一个智能指针指向它，即完成从 DST 到 Sized 类型的转变。

#### 特征对象

在 Rust 中，实现不同类型组成的数组只有两个办法：枚举和特征对象，前者限制较多，后者是最常用的解决办法。

```rust
trait Draw {
    fn draw(&self);
}

struct Button {
    id: u32,
}

impl Draw for Button {
    fn draw(&self) {
        println!("这是屏幕上第{}号按钮", self.id)
    }
}

struct Select {
    id: u32,
}

impl Draw for Select {
    fn draw(&self) {
        println!("这个选择框贼难用{}", self.id)
    }
}

fn main() {
    let elems: Vec<Box<dyn Draw>> = vec![Box::new(Button { id: 1 }),
                                         Box::new(Select { id: 2 })];
    for e in elems {
        e.draw()
    }
}
```

这里将不同类型的 Button 和 Select 包装成 Draw 特征对象，放入一个数组中。`Box<dyn Draw>` 就是特征对象。

### Box 内存布局

先看看 `Vec<i32>` 的内存布局：

```sh
(stack)    (heap)
┌──────┐   ┌───┐
│ vec1 │──→│ 1 │
└──────┘   ├───┤
           │ 2 │
           ├───┤
           │ 3 │
           ├───┤
           │ 4 │
           └───┘
```

`Vec` 和 `String` 都是智能指针，该智能指针存储在栈中，指向堆中的数组数据。

那如果数组中每个元素都是 `Box` 对象，即 `Vec<Box<i32>>` 的内存布局：

```sh
                    (heap)
(stack)    (heap)   ┌───┐
┌──────┐   ┌───┐ ┌─→│ 1 │
│ vec2 │──→│B1 │─┘  └───┘
└──────┘   ├───┤    ┌───┐
           │B2 │───→│ 2 │
           ├───┤    └───┘
           │B3 │─┐  ┌───┐
           ├───┤ └─→│ 3 │
           │B4 │─┐  └───┘
           └───┘ │  ┌───┐
                 └─→│ 4 │
                    └───┘
```

这里 `B1` 代表被 Box 分配到堆上的值 1.

可以看出智能指针 vec2 依然存储在栈上，指向一个堆上的数组，该数组的每个元素都是一个 Box 智能指针，Box 智能指针又指向存储在堆上的实际值。

因此，当我们从数组中取出某个元素时，取到的是智能指针 Box，需要对该智能指针解引用，才能取到最终值：

```rust
fn main() {
    let arr = vec![Box::new(1), Box::new(2)];
    let (first, second) = (&arr[0], &arr[1]);
    let sum = **first + **second;
}
```

要点：

- 使用 `&` 借用数组中的元素，否则会报所有权错误
- 表达式不能隐式的解引用，必须使用 `**` 做两次解引用，第一次将 `&Box<i32>` 类型转换为 `Box<i32>`，第二次将 `Box<i32>` 转换成 `i32`

### Box::leak

`Box::leak` 消耗掉 `Box` 并强制目标值从内存中泄露。

k