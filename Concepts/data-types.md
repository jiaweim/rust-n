# æ•°æ®ç±»å‹

- [æ•°æ®ç±»å‹](#æ•°æ®ç±»å‹)
  - [2. æ ‡é‡ç±»å‹](#2-æ ‡é‡ç±»å‹)
    - [2.4. Boolean ç±»å‹](#24-boolean-ç±»å‹)
    - [2.5. å­—ç¬¦ç±»å‹](#25-å­—ç¬¦ç±»å‹)
  - [å­—é¢é‡å’Œè¿ç®—ç¬¦](#å­—é¢é‡å’Œè¿ç®—ç¬¦)
  - [3. å¤åˆç±»å‹](#3-å¤åˆç±»å‹)
    - [3.1. Tuple](#31-tuple)
    - [3.2. Array](#32-array)
      - [3.2.1. è®¿é—®æ•°ç»„å…ƒç´ ](#321-è®¿é—®æ•°ç»„å…ƒç´ )
      - [3.2.2. æ— æ•ˆæ•°ç»„è®¿é—®](#322-æ— æ•ˆæ•°ç»„è®¿é—®)

Last updated: 2023-10-09, 21:40
@author Jiawei Mao
****
## 2. æ ‡é‡ç±»å‹

æ ‡é‡ç±»å‹è¡¨ç¤ºå•ä¸ªå€¼ã€‚Rust æœ‰ 4 ç§ä¸»è¦çš„æ ‡é‡ç±»å‹ï¼š

- æ•´æ•°
- æµ®ç‚¹æ•°
- å¸ƒå°”å€¼
- å­—ç¬¦

```rust
fn main() {
    // å˜é‡å¯ä»¥ç»™å‡ºç±»å‹è¯´æ˜ã€‚
    let logical: bool = true;

    let a_float: f64 = 1.0;  // å¸¸è§„è¯´æ˜
    let an_integer = 5i32; // åç¼€è¯´æ˜

    // å¦åˆ™ä¼šæŒ‰é»˜è®¤æ–¹å¼å†³å®šç±»å‹ã€‚
    let default_float = 3.0; // `f64`
    let default_integer = 7;   // `i32`

    // ç±»å‹ä¹Ÿå¯æ ¹æ®ä¸Šä¸‹æ–‡è‡ªåŠ¨æ¨æ–­ã€‚
    let mut inferred_type = 12; // æ ¹æ®ä¸‹ä¸€è¡Œçš„èµ‹å€¼æ¨æ–­ä¸º i64 ç±»å‹
    inferred_type = 4294967296i64;

    // å¯å˜çš„ï¼ˆmutableï¼‰å˜é‡ï¼Œå…¶å€¼å¯ä»¥æ”¹å˜ã€‚
    let mut mutable = 12; // Mutable `i32`
    mutable = 21;

    // æŠ¥é”™ï¼å˜é‡çš„ç±»å‹å¹¶ä¸èƒ½æ”¹å˜ã€‚
    // mutable = true;

    // ä½†å¯ä»¥ç”¨é®è”½ï¼ˆshadowï¼‰æ¥è¦†ç›–å‰é¢çš„å˜é‡ã€‚
    let mutable = true;
}
```

### 2.4. Boolean ç±»å‹

Boolean ç±»å‹æœ‰ 2 ä¸ªå€¼ï¼štrue å’Œ falseã€‚

Boolean ç±»å‹åªæœ‰ 1 ä¸ªå­—èŠ‚å¤§å°ï¼Œä½¿ç”¨ `bool` æ³¨é‡Šç±»å‹ã€‚

```rust
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
```

### 2.5. å­—ç¬¦ç±»å‹

`char` è¡¨ç¤ºå­—ç¬¦ç±»å‹ã€‚ç¤ºä¾‹ï¼š

```rust
fn main() {
    let c = 'z';
    let z: char = 'â„¤'; // with explicit type annotation
    let heart_eyed_cat = 'ğŸ˜»';
}
```

`char` å­—é¢é‡ä½¿ç”¨å•å¼•å·ï¼Œè€Œå­—ç¬¦ä¸²å­—é¢é‡ä½¿ç”¨åŒå¼•å·ã€‚Rust ä¸­ `char` ç±»å‹åŒ…å« 4 ä¸ªå­—èŠ‚ï¼Œä¸ Unicode æ ‡é‡å€¼å¯¹åº”ã€‚

Unicode æ ‡é‡å€¼èŒƒå›´ä¸ºï¼š[U+0000, U+D7FF] å’Œ [U+E000, U+10FFFF]ã€‚

## å­—é¢é‡å’Œè¿ç®—ç¬¦

æ•´æ•° 1ã€æµ®ç‚¹æ•° 1.2ã€å­—ç¬¦ 'a'ã€å­—ç¬¦ä¸² "abc"ã€å¸ƒå°”å€¼ true å’Œå•å…ƒç±»å‹ () å¯ä»¥ç”¨æ•°å­—ã€æ–‡å­—æˆ–ç¬¦å·ä¹‹ç±»çš„ â€œå­—é¢é‡â€ï¼ˆliteralï¼‰æ¥è¡¨ç¤ºã€‚

å¦å¤–ï¼Œé€šè¿‡åŠ å‰ç¼€ 0xã€0oã€0bï¼Œæ•°å­—å¯ä»¥ç”¨åå…­è¿›åˆ¶ã€å…«è¿›åˆ¶æˆ–äºŒè¿›åˆ¶è®°æ³•è¡¨ç¤ºã€‚

ä¸ºäº†æ”¹å–„å¯è¯»æ€§ï¼Œå¯ä»¥åœ¨æ•°å€¼å­—é¢é‡ä¸­æ’å…¥ä¸‹åˆ’çº¿ï¼Œæ¯”å¦‚ï¼š1_000 ç­‰åŒäº 1000ï¼Œ0.000_001 ç­‰åŒäº 0.000001ã€‚

æˆ‘ä»¬éœ€è¦æŠŠå­—é¢é‡çš„ç±»å‹å‘Šè¯‰ç¼–è¯‘å™¨ã€‚å¦‚å‰é¢å­¦è¿‡çš„ï¼Œæˆ‘ä»¬ä½¿ç”¨ u32 åç¼€æ¥è¡¨æ˜å­—é¢é‡æ˜¯ä¸€ä¸ª 32 ä½æ— ç¬¦å·æ•´æ•°ï¼Œi32 åç¼€è¡¨æ˜å­—é¢é‡æ˜¯ä¸€ä¸ª 32 ä½æœ‰ç¬¦å·æ•´æ•°ã€‚

```rust
fn main() {
    // æ•´æ•°ç›¸åŠ 
    println!("1 + 2 = {}", 1u32 + 2);

    // æ•´æ•°ç›¸å‡
    println!("1 - 2 = {}", 1i32 - 2);
    // è¯•ä¸€è¯• ^ å°è¯•å°† `1i32` æ”¹ä¸º `1u32`ï¼Œä½“ä¼šä¸ºä»€ä¹ˆç±»å‹å£°æ˜è¿™ä¹ˆé‡è¦

    // çŸ­è·¯æ±‚å€¼çš„å¸ƒå°”é€»è¾‘
    println!("true AND false is {}", true && false);
    println!("true OR false is {}", true || false);
    println!("NOT true is {}", !true);

    // ä½è¿ç®—
    println!("0011 AND 0101 is {:04b}", 0b0011u32 & 0b0101);
    println!("0011 OR 0101 is {:04b}", 0b0011u32 | 0b0101);
    println!("0011 XOR 0101 is {:04b}", 0b0011u32 ^ 0b0101);
    println!("1 << 5 is {}", 1u32 << 5);
    println!("0x80 >> 2 is 0x{:x}", 0x80u32 >> 2);

    // ä½¿ç”¨ä¸‹åˆ’çº¿æ”¹å–„æ•°å­—çš„å¯è¯»æ€§ï¼
    println!("One million is written as {}", 1_000_000u32);
}
```

## 3. å¤åˆç±»å‹

å¤åˆç±»å‹ï¼ˆcompound typeï¼‰å°†å¤šä¸ªå€¼ç»„åˆä¸ºä¸€ç§ç±»å‹ã€‚Rust æœ‰ä¸¤ç§åŸºæœ¬å¤åˆç±»å‹ï¼šTuple å’Œ arrayã€‚

- æ•°ç»„ï¼ˆarrayï¼‰ï¼šå¦‚ `[1, 2, 3]`
- å…ƒç»„ï¼ˆtupleï¼‰ï¼šå¦‚ `(1, true)`

### 3.1. Tuple

å…ƒç»„æ˜¯ä¸€ä¸ªå¯ä»¥åŒ…å«å„ç§ç±»å‹å€¼çš„ç»„åˆã€‚å…ƒç»„ä½¿ç”¨æ‹¬å· `()` æ¥æ„é€ ï¼ˆconstructï¼‰ï¼Œè€Œæ¯ä¸ªå…ƒç»„è‡ªèº«åˆæ˜¯ä¸€ä¸ªç±»å‹æ ‡è®°ä¸º `(T1, T2, ...)` çš„å€¼ï¼Œå…¶ä¸­ `T1`ã€`T2` æ˜¯æ¯ä¸ªå…ƒç´ çš„ç±»å‹ã€‚å‡½æ•°å¯ä»¥ä½¿ç”¨å…ƒç»„æ¥è¿”å›å¤šä¸ªå€¼ï¼Œå› ä¸ºå…ƒç»„å¯ä»¥æ‹¥æœ‰ä»»æ„å¤šä¸ªå€¼ã€‚

```rust
// å…ƒç»„å¯ä»¥å……å½“å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼
fn reverse(pair: (i32, bool)) -> (bool, i32) {
    // å¯ä»¥ä½¿ç”¨ `let` æŠŠä¸€ä¸ªå…ƒç»„çš„æˆå‘˜ç»‘å®šåˆ°ä¸€äº›å˜é‡
    let (integer, boolean) = pair;

    (boolean, integer)
}

// åœ¨ â€œåŠ¨æ‰‹è¯•ä¸€è¯•â€ çš„ç»ƒä¹ ä¸­è¦ç”¨åˆ°ä¸‹é¢è¿™ä¸ªç»“æ„ä½“ã€‚
#[derive(Debug)]
struct Matrix(f32, f32, f32, f32);

fn main() {
    // åŒ…å«å„ç§ä¸åŒç±»å‹çš„å…ƒç»„
    let long_tuple = (1u8, 2u16, 3u32, 4u64,
                      -1i8, -2i16, -3i32, -4i64,
                      0.1f32, 0.2f64,
                      'a', true);

    // é€šè¿‡å…ƒç»„çš„ä¸‹æ ‡æ¥è®¿é—®å…·ä½“çš„å€¼
    println!("long tuple first value: {}", long_tuple.0);
    println!("long tuple second value: {}", long_tuple.1);

    // å…ƒç»„ä¹Ÿå¯ä»¥å……å½“å…ƒç»„çš„å…ƒç´ 
    let tuple_of_tuples = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16);

    // å…ƒç»„å¯ä»¥æ‰“å°
    println!("tuple of tuples: {:?}", tuple_of_tuples);

    // ä½†å¾ˆé•¿çš„å…ƒç»„æ— æ³•æ‰“å°
    // let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
    // println!("too long tuple: {:?}", too_long_tuple);
    // è¯•ä¸€è¯• ^ å–æ¶ˆä¸Šé¢ä¸¤è¡Œçš„æ³¨é‡Šï¼Œé˜…è¯»ç¼–è¯‘å™¨ç»™å‡ºçš„é”™è¯¯ä¿¡æ¯ã€‚

    let pair = (1, true);
    println!("pair is {:?}", pair);

    println!("the reversed pair is {:?}", reverse(pair));

    // åˆ›å»ºå•å…ƒç´ å…ƒç»„éœ€è¦ä¸€ä¸ªé¢å¤–çš„é€—å·ï¼Œè¿™æ˜¯ä¸ºäº†å’Œè¢«æ‹¬å·åŒ…å«çš„å­—é¢é‡ä½œåŒºåˆ†ã€‚
    println!("one element tuple: {:?}", (5u32, ));
    println!("just an integer: {:?}", (5u32));

    // å…ƒç»„å¯ä»¥è¢«è§£æ„ï¼ˆdeconstructï¼‰ï¼Œä»è€Œå°†å€¼ç»‘å®šç»™å˜é‡
    let tuple = (1, "hello", 4.5, true);

    let (a, b, c, d) = tuple;
    println!("{:?}, {:?}, {:?}, {:?}", a, b, c, d);

    let matrix = Matrix(1.1, 1.2, 2.1, 2.2);
    println!("{:?}", matrix)
}
```

ç¤ºä¾‹ï¼š

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

ä»å…ƒç»„è·å–å€¼ï¼ˆdestructuringï¼‰ï¼š

```rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {y}");
}
```

ä¹Ÿå¯ä»¥ç›´æ¥ç”¨ `.index` æ–¹å¼è®¿é—® tuple å€¼ï¼š

```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```

æ²¡æœ‰å€¼çš„å…ƒç»„æœ‰ä¸€ä¸ªç‰¹æ®Šåç§°ï¼š*unit*ã€‚è¯¥å€¼åŠå…¶ç±»å‹éƒ½å†™ä¸º `()`ã€‚è¡¨ç¤ºè¡¨è¾¾å¼ä¸è¿”å›ä»»ä½•å€¼ã€‚

### 3.2. Array

æ•°ç»„ï¼Œä¸å…ƒç»„ä¸åŒçš„æ˜¯ï¼šæ•°ç»„çš„æ¯ä¸ªå…ƒç´ ç±»å‹å¿…é¡»ç›¸åŒã€‚å£°æ˜æ•°ç»„æ–¹å¼ï¼š

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

å½“å¸Œæœ›å°†æ•°æ®ä¿å­˜åœ¨æ ˆè€Œä¸æ˜¯å †ä¸Šï¼Œæˆ–è€…éœ€è¦ä¿å­˜å…ƒç´ çš„æ•°é‡å›ºå®šï¼Œå°±ä½¿ç”¨æ•°ç»„ã€‚

æ•°ç»„æ²¡æœ‰ `vector` çµæ´»ï¼Œ`vector` å¯ä»¥å¢å¤§æˆ–ç¼©å°ã€‚å½“å·²çŸ¥å…ƒç´ ä¸ªæ•°ï¼Œæ¨èä½¿ç”¨æ•°ç»„ï¼š

```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```

å£°æ˜æ—¶æŒ‡å®šç±»å‹å’Œå¤§å°ï¼š

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

å£°æ˜æ‰€æœ‰å€¼ç›¸åŒçš„æ•°ç»„ï¼š

```rust
let a = [3; 5];
```

è¡¨ç¤ºæ•°ç»„ `a` å¤§å°ä¸º 5ï¼Œæ‰€æœ‰å…ƒç´ éƒ½æ˜¯ 3ï¼Œç­‰ä»·äº `let a = [3, 3, 3, 3, 3];`ã€‚

#### 3.2.1. è®¿é—®æ•°ç»„å…ƒç´ 

- ä½¿ç”¨æ•°ç»„è®¿é—®

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```

#### 3.2.2. æ— æ•ˆæ•°ç»„è®¿é—®

ä¸‹é¢çœ‹çœ‹ç´¢å¼•è¶…å‡ºæ•°ç»„èŒƒå›´ï¼Œä¼šæœ‰ä»€ä¹ˆæ•ˆæœï¼š

```rust
use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();

    io::stdin()
        .read_line(&mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!("The value of the element at index {index} is: {element}");
}
```

è¯¥ä»£ç ç¼–è¯‘æ²¡é—®é¢˜ï¼Œè¾“å…¥ 0, 1, 2, 3, 4ï¼Œç¨‹åºä¼šè¾“å‡ºå¯¹åº”ä½ç½®çš„å…ƒç´ å€¼ã€‚å¦‚æœè¶…å‡ºè¯¥èŒƒå›´ï¼Œä¾‹å¦‚ 10ï¼Œä¼šæ‰‹ç²—å¦‚ä¸‹é”™è¯¯ä¿¡æ¯

```
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10',
src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

ç¼–è¯‘æ—¶ Rust ä¸å¯èƒ½é¢„çŸ¥ä½ è¾“å…¥çš„ç´¢å¼•å€¼ï¼Œæ‰€ä»¥è¿™æ˜¯ä¸€ä¸ªè¿è¡Œæ—¶é”™è¯¯ã€‚

